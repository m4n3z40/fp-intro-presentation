<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Functional Programming: An Introduction</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <img src="img/lambda.png" alt="Lambda letter" style="border-radius: 100%;">
          <h2>Introduction to FP</h1>
          <h4>(w/ Javascript)</h2>
        </section>

        <section>
          <blockquote>
            "A monad is just a monoid in the category of endofunctors..."
          </blockquote>
        </section>
        
        <section>
          <img src="img/james-iry-about-fpers.png" alt="">
        </section>
        
        <section>
          <h3>Why to FP?</h3>
        </section>
        
        <section>
          <h3>Some facts:</h3>
          <h4>(that may blow your mind)</h4>
          <ul>
            <li class="fragment">Elegant, readable and simple code makes it hard for bugs to hide</li>
            <li class="fragment">70% of time spent while maintaining code is spent <em>reading it</em></li>
            <li class="fragment">Global average for a coder's <abbr title="lines of code">loc</abbr> written p/ day is ~10</li>
          </ul>
        </section>

        <section>
          <img src="img/blow-mind.gif" alt="Mindblown Meme" width="480">
        </section>
        
        <section>
          <h3>Why to FP?</h3>
          <p class="fragment">Because it allows us to write a more...</p>
          <ul>
            <li class="fragment">...reusable code</li>
            <li class="fragment">...testable code</li>
            <li class="fragment">...declarative code</li>
            <li class="fragment">...readable code</li>
          </ul>
          <p class="fragment">In general, a more <strong>reliable</strong> & <strong>maintainable</strong> code in the long term</p>
        </section>

        <section>
          <h3>Readability Curve</h3>
          <img src="img/readability-curve.png" alt="">
          <p><small>Source: <a href="https://github.com/getify/Functional-Light-JS/blob/master/ch1.md">https://github.com/getify/Functional-Light-JS/blob/master/ch1.md</a></small></p>
        </section>

        <section>
          <h3>How to FP?</h3>
          <p class="fragment">Some mandatory topics:</p>
          <ul>
            <li class="fragment">First Class Functions</li>
            <li class="fragment">High-Order Functions & Closures</li>
            <li class="fragment">Function Purity</li>
            <li class="fragment">Managing Function Input</li>
            <li class="fragment">Function Composition</li>
            <li class="fragment">Value Immutability</li>
            <li class="fragment">Array Operations</li>
            <li class="fragment">Recursion</li>
            <li class="fragment">Monads</li>
          </ul>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li style="color: crimson">First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li>Managing Function Input</li>
              <li>Function Composition</li>
              <li>Value Immutability</li>
              <li>Array Operations</li>
              <li>Recursion</li>
              <li>Monads</li>
            </ul>
          </section>
          
          <section>
            <h3>First Class Functions</h3>
            <h4 class="fragment">(or functions as values)</h4>
          </section>

          <section>
            <p>The majority of patterns and tools around FP requires functions to be treated as <em>first-class citizens</em></p>
            <p class="fragment">Which means they can:</p>
          </section>

          <section>
            <h3>Be assigned to variables</h3>
          
            <pre><code class="javascript" data-trim>
              // anonymous functions
              const aFunction = function () { 
                console.log('hello fp');
              };
              // or named functions
              const aFunction = function aFunctionName() { 
                console.log('hello fp');
              };
              // or arrow functions
              const aFunction = () => console.log('hello fp');
              // or even borrowed methods
              const aFunction = someObj.someOtherFunction;
            </code></pre>
          </section>

          <section>
            <h3>Be assigned to data structures</h3>

            <pre><code class="javascript" data-trim>
              // With objects
              const obj = {
                methodAnon: function() { },
                methodNamed: function aFunctionName() { },
                methodArrow: () => { },
                methodBorrowed: otherObj.someOtherFunction;
              };
              // Or with arrays
              const arr = [
                function() { },
                function aFunctionName() { },
                () => { },
                otherObj.someOtherFunction
              ];
            </code></pre>
          </section>

          <section>
            <h3>Be used as other functions arguments</h3>
  
            <pre><code class="javascript" data-trim>
              const hello = () => {
                console.log('hello fp');
              };

              const callFn = fn => fn();

              // ...

              callFn(hello); // hello fp
            </code></pre>
          </section>

          <section>
            <h3>Be returned from other functions</h3>

            <pre><code class="javascript" data-trim>
              const getHello = () => {
                return () => {
                  console.log('hello fp');
                };
              };
              // or the shorter
              const getHello = () => () => console.log('hello fp');

              // ...

              const hello = getHello();
              hello(); // hello fp
              // or in one go
              getHello()(); // hello fp
            </code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li style="color: crimson">High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li>Managing Function Input</li>
              <li>Function Composition</li>
              <li>Value Immutability</li>
              <li>Array Operations</li>
              <li>Recursion</li>
              <li>Monads</li>
            </ul>
          </section>

          <section>
            <h3>High-Order Functions & Closures</h3>
            <h4 class="fragment">(or working with stateful functions)</h4>
          </section>

          <section>
            <h3>High-Order Functions</h3>
            <p>A high-order function is a function that does at least one of the following:</p>
          </section>

          <section>
            <h3>1. Takes one or more functions as arguments</h3>

            <pre class="fragment"><code class="javascript" data-trim>
              const highOrderSecret = (fnArg) => {
                const secret = 'FP rulez!';

                fnArg(fnArg);
              };

              const logSecret = (secret) => console.log(secret);
              const saveSecret = (secret) => secretStorage.add(secret);

              // ...

              highOrderSecret(logSecret); // FP rulez!
              highOrderSecret(saveSecret);
            </code></pre>

            <p class="fragment">Useful to separate concerns and abstract/decouple logic</p>
          </section>

          <section>
            <h3>2. Returns a function as it's result</h3>

            <pre class="fragment"><code class="javascript" data-trim>
              const makeSecret = () => {
                const secret = 'FP rulez!';

                return () => secret; // Btw, this is a closure
              };

              const getSecret = makeSecret();

              console.log(getSecret()); // FP rulez!
            </code></pre>

            <p class="fragment">Useful to "hide" state (achieve privacy), persist state to be processed/used later and compose/add behaviour to other functions</p>
          </section>

          <section>
            <h3>Closures</h3>

            <p>A closure is a function that refers to <em>"free variables"</em> (variables defined in parent scopes)</p>
            <p class="fragment">In other words, it's a function that <em>"remembers"</em> the state/environment where it was created</p>
          </section>
          
          <section>
            <h3>A closer look into a closure</h3>
            <pre><code class="javascript" data-trim style="max-height: 600px">
              // global scope
              const makeSecret = () => {
                // scope 0
                const secret = 'FP rulez';
                // following will log undefined because parent a scope
                // does not have access to child scopes
                console.log(secretSuffix); // undefined

                return () => {
                  // scope 1
                  const secretSuffix = '!!!!!';

                  return secret + secretSuffix;
                };
              };

              console.log(secret); // undefined - we're in global scope here

              const getSecret = makeSecret();
              // It remembers it's own scope plus parent scopes
              console.log(getSecret()); // FP rulez!!!!!
            </code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li style="color: crimson">Function Purity</li>
              <li>Managing Function Input</li>
              <li>Function Composition</li>
              <li>Value Immutability</li>
              <li>Array Operations</li>
              <li>Recursion</li>
              <li>Monads</li>
            </ul>
          </section>

          <section>
            <h3>Function Purity</h3>
            <h4 class="fragment">(or avoiding side effects)</h4>
          </section>

          <section>
            <p>A function is considered <em>pure</em> if it does not break the following "laws":</p>
            <ol>
              <li class="fragment">
                <em>Always</em> has to return the 
                <em>same output</em> given the 
                <em>same input</em>
              </li>
              <li class="fragment">
                Does <em>not</em> depend on/causes any <em>side effect</em> (state mutations, I/O operations) 
              </li>
            </ol>
          </section>

          <section>
            <h3>Pure Functions</h3>

            <pre><code class="javascript" data-trim>
              const add = (a, b) => a + b;

              const getCircleArea = r => Math.PI * r * r;

              const getFullName = (first, last) => `${first} ${last}`;

              const logUserIn = user => Object.assign(
                {}, 
                user, 
                { loggedIn: true }
              ); 
            </code></pre>
          </section>

          <section>
            <h3>Impure Functions</h3>

            <pre><code class="javascript" data-trim>
              // I/O operation
              const logMsg = msg => console.log(msg);

              // Different outputs, same input
              const getRandom = (max) => Math.random() * max;

              // depends on mutable state
              const getFullName = (first, last) => 
                `${globalNamePrefix} ${first} ${last}`;

              // Mutating object state
              const logUserIn = user => user.loggedIn = true;
             </code></pre>
          </section>
          <section>
            <p>A program without any observable side effect is also a program that <em>accomplishes nothing useful</em></p>
            <p class="fragment">but, side effects should be <em>avoided</em> where possible</p>
            <p class="fragment">as they make programs <em>hard to follow/read</em>, hard to test and hard to maintain</p>
            <p class="fragment">most of a program codebase should be composed of small, single-purpose and <em>pure</em> functions</p>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li style="color: crimson">Managing Function Input</li>
              <li>Function Composition</li>
              <li>Value Immutability</li>
              <li>Array Operations</li>
              <li>Recursion</li>
              <li>Monads</li>
            </ul>
          </section>

          <section>
            <h3>Managing Function Input</h3>
            <h4 class="fragment">(or manipulating function arguments)</h4>
          </section>

          <section>
            <h4>Args vs Params</h4>
            <p>Question: what's the difference between arguments and parameters?</p>

            <pre class="fragment"><code class="javascript" data-trim>
              // firstName, middleName and lastName are parameters
              const getFullName = (firstName, middleName, lastName) =>
                `${firstName} ${middleName} ${lastName}`;

              // All strings passed into getFullName() call are arguments  
              getFullName('Allan', 'Marques', 'Baptista');

              // arguments < parameters - perfectly valid in JS
              getFullName('Emperor', 'Palpatine');

              // arguments > parameters - also valid
              getFullName('Some', 'Big', 'Ass', 'Freaking', 'Name');
            </code></pre>
          </section>

          <section>
            <h4>Args vs Params</h4>
            <p><em>Parameter</em> is the variable which is part of the function signature</p>
            <p class="fragment"><em>Argument</em> is the value/variable/reference/expression being passed in during a function call</p>
          </section>

          <section>
            <h4>Arity</h4>
            <p>The number of parameters a function expects in it's signature is called <em>arity</em></p>

            <pre class="fragment"><code class="javascript" data-trim>
              const double = n => n * 2; // arity = 1 (unary)

              // arity = 3 (ternary)
              const getFullName = (firstName, middleName, lastName) =>
                `${firstName} ${middleName} ${lastName}`; 
            </code></pre>

            <p class="fragment">It's possible to get a function's arity through the <code>Function.prototype.length</code> property</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const double = n => n * 2;
              console.log(double.length); // 1 
            </code></pre>
          </section>

          <section>
            <p>
              By combining the power of <em>high-order functions (HoF)</em>, 
              knowledge of function <em>arity</em> and <em>loose arguments</em> application, 
              we can build powerful abstractions
            </p>
          </section>

          <section>
            <h4>Forcing Unary Functions</h4>
            <p class="fragment">Sometimes we need to ensure a function that expects more the one parameter to receive only one argument</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const strArr = ['1', '2', '3', '4', '5'];
              const mumArr = strArr.map(parseInt);

              console.log(numArr); // [1, NaN, NaN, NaN, NaN]
            </code></pre>

            <p class="fragment">That happens because parseInt's signature is:<br><code>parseInt(str, radix = 10)</code></p>
            <p class="fragment">And <code>Array.prototype.map</code> calls any function passed in with the arguments:<br><code>fn(item, index, arr)</code></p>
          </section>

          <section>
            <h4>Forcing Unary Functions</h4>
            <p>We can fix that with a utility <em>HoF</em> usually called <em>unary</em></p>
            
            <div class="fragment">
              <p>That can be implemented in JS like so:</p>

              <pre><code class="javascript" data-trim>
                const unary = fn => 
                  param => fn(param);
              </code></pre>
            </div>

            <div class="fragment">
              <p>And used like this:</p>

              <pre><code class="javascript" data-trim>
                const strArr = ['1', '2', '3', '4', '5'];
                const mumArr = strArr.map(unary(parseInt));

                console.log(numArr); // [1, 2, 3, 4, 5]
              </code></pre>
            </div>
          </section>

          <section>
            <h4>Partial Application</h4>

            <p class="fragment">Calling a function and passing some arguments to it like:<br><code>foo(bar, baz);</code></p>
            <p class="fragment">can also be described as <em>applying</em> function foo to the arguments bar and baz</p>
          </section>

          <section>
            <h4>Partial Application</h4>

            <p>Means <em>fixing/binding</em> a number of arguments to a function producing another function with <em>smaller arity</em></p>

            <p class="fragment">It's useful when we know some of the arguments that'll be applied to a function <em>ahead of time</em></p>
            <p class="fragment">But the rest of the arguments we'll only know at a later point in execution time.</p>
          </section>

          <section>
            <h4>Partial Application</h4>

            <p>A partial function application utility can easily be implemented like so:</p>

            <pre><code class="javascript" data-trim>
              const partial = (fn, ...eagerArgs) => 
                (...lazyArgs) => fn(...eagerArgs, ...lazyArgs);
            </code></pre>

            <div class="fragment">
              <p>And it's used like this:</p>

              <pre><code class="javascript" data-trim>
                const fullName = (preferedTreatment, firstName, lastName) =>
                  `${preferedTreatment} ${lastName}, ${firstName}`;

                const maleName = partial(fullName, 'Sir');
                const femaleName = partial(fullName, 'Ma\'am');

                maleName('Allan', 'Baptista'); // Sir Baptista, Allan
                femaleName('Nadia', 'Carvalho'); // Ma'am Carvalho, Nadia
              </code></pre>
            </div>
          </section>

          <section>
            <h4>Partial Application</h4>

            <p>It's also possible to implement a utility that partially applies the <em>final arguments</em> like so:</p>

            <pre><code class="javascript" data-trim>
              const partialRight = (fn, ...rightArgs) => 
                (...leftArgs) => fn(...leftArgs, ...rightArgs);
            </code></pre>

            <div class="fragment">
              <p>That can be used like this:</p>

              <pre><code class="javascript" data-trim>
                const fullName = (preferedTreatment, firstName, lastName) =>
                  `${preferedTreatment} ${lastName}, ${firstName}`;

                const kirk = partial(fullName, 'James', 'Kirk');

                kirk('Sir'); // Sir Kirk, James
                kirk('Captain'); // Captain Kirk, James
              </code></pre>
            </div>
          </section>

          <section>
            <h4>Currying</h4>

            <p class="fragment">It's a <i>special</i> kind of partial application that only applies the actual function once it's gathered all parameters it expects</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const curriedFullName = preferedTreatment =>
                firstName =>
                    lastName =>
                      `${preferedTreatment} ${lastName}, ${firstName}`;

              const getName = curriedFullName('Mr'); // preferedTreatment = 'Mr'
              const getLastName = getName('James'); // firstName = 'James'
              getLastName('Bond'); // Mr. Bond, James

              // or in one go

              curriedFullName('Sir')('Leonard')('Nimoy'); // Sir Nimoy, Leonard 
            </code></pre>
          </section>

          <section>
            <h4>Currying</h4>

            <p>In Haskell all functions are curried by default, but in javascript we need to write a utility function to achieve the same</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const autoCurry = (fn, arity = fn.length) =>
                (...args) => 
                  args.length >= arity ?
                    fn(...args) :
                    autoCurry(partial(fn, ...args), arity - args.length);
            </code></pre>
          </section>

          <section>
            <h4>Currying</h4>

            <pre><code class="javascript" data-trim style="max-height: 600px">
              const curriedFullName = autoCurry(
                (preferedTreatment, firstName, lastName) =>
                  `${preferedTreatment} ${lastName}, ${firstName}`
              );

              const getName = curriedFullName('Mr'); // preferedTreatment = 'Mr'
              const getLastName = getName('James'); // firstName = 'James'
              getLastName('Bond'); // Mr. Bond, James

              // or
              curriedFullName('Sir')('Leonard')('Nimoy'); // Sir Nimoy, Leonard
              // or
              curriedFullName('Sir')('Rowan', 'Atkinson'); // Sir Atkinson, Rowan
              // or
              curriedFullName('Mr', 'Mickey', 'Mouse'); // Mr Mouse, Mickey
            </code></pre>
          </section>

          <section>
            <h4>Currying</h4>

            <p>Note that the strict implementation of currying produces only <em>unary</em> functions after each call</p>
            <p class="fragment">So the implementation showed here should be called <em>loose currying</em>, which is often more useful</p>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li>Managing Function Input</li>
              <li style="color: crimson">Function Composition</li>
              <li>Value Immutability</li>
              <li>Array Operations</li>
              <li>Recursion</li>
              <li>Monads</li>
            </ul>
          </section>

          <section>
            <h3>Function Composition</h3>
            <h4 class="fragment">(or playing with building blocks)</h4>
          </section>

          <section>
            <p>When a program/application is well split into simple, single-purpose and pure functions a repeating pattern starts to come up:</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const outputData = freeze(enhance(escape(inputData)));
            </code></pre>

            <p class="fragment">And to avoid repetition, it's common to create <em>composed abstractions</em>:</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const transformData = data => freeze(enhance(escape(data)));

              // later somewhere...
              const outputData = transformData(inputData);

              // and even later...
              const dataToPersist = transformData(inputData);
            </code></pre>
          </section>

          <section>
            <h4>A better way</h4>

            <p class="fragment">What if there was a way to achieve the same thing in a <em>declarative way</em>?</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const transformData = compose(freeze, enhance, escape);

              // later somewhere...
              const outputData = transformData(inputData);
            </code></pre>
          </section>

          <section>
            <p><code>compose(...fns)</code> takes a list of functions</p>
            <p class="fragment">and returns another function that applies each function from <em>right to left</em>, so:</p>
            <pre class="fragment"><code class="javascript" data-trim>
              // This
              const transformData = compose(freeze, enhance, escape);
              transformData(...args);

              // is the same as this
              const escaped = escape(...args);
              const enhanced = enhance(escaped);
              const outputData = freeze(enhanced);

              // or this
              const outputData = freeze(enhance(escape(...args)));
            </code></pre>
          </section>

          <section>
            <p>One can implement <code>compose</code> in JS like so:</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const compose = (...fns) =>
                (...args) => fns
                  .slice(0, -1)
                  .reduceRight(
                    (res, fn) => fn(res),
                    fns[fns.length - 1](...args)
                  );
            </code></pre>

            <p class="fragment">Note that all functions besides the first one to be applied are expected to be <em>unary</em></p>
            <p class="fragment">as it's not possible to return more the one value from a function</p>
          </section>

          <section>
            <h4>Piping</h4>
            <p>Sometimes reading the flow of data from right to left can be counter-intuitive</p>
            <p class="fragment">to fix that, we can build a variation of <code>compose</code> that applies each function from <em>left to right</em></p>
            <p class="fragment">that variation is usually called <em>pipe or pipeline</em></p>

            <pre class="fragment"><code class="javascript" data-trim>
              const transformData = pipe(escape, enhance, freeze);

              // later somewhere...
              const outputData = transformData(inputData);
            </code></pre>
          </section>

          <section>
            <h4>Piping</h4>
            <p><code>pipe</code> can be implemented like so:</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const pipe = (firstFn, ...restFns) =>
                (...args) => restFns.reduce(
                  (res, fn) => fn(res),
                  firstFn(...args)
                );
            </code></pre>

            <p class="fragment">Other than the difference on how data flows <code>compose</code> and <code>pipe</code> works in the same way</p>

            <p class="fragment"><small>(Except this implementation o <code>pipe</code> is a little bit more performant than <code>compose</code>'s implementation showed before)</small></p>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li>Managing Function Input</li>
              <li>Function Composition</li>
              <li style="color: crimson">Value Immutability</li>
              <li>Array Operations</li>
              <li>Recursion</li>
              <li>Monads</li>
            </ul>
          </section>

          <section>
            <h3>Value Immutability</h3>
            <h4 class="fragment">(or writing predictable logic)</h4>
          </section>

          <section>
            <p>In javascript (and the majority of hybrid/OO languages) immutability is usually <em>not natively enforced</em> on objects</p>
            <p class="fragment">Some may naively think assigning objects with the <code>const</code> keyword prevents objects from being mutated</p>
          </section>

          <section>
            <pre><code class="javascript" data-trim>
              const config = { cannotChange: 'Never changed' };

              config.cannotChange = 'Chaos';

              console.log(config); // { cannotChange: 'Chaos' }

              // but the following throws a TypeError
              config = { cannotChange: 'Invalid' };
            </code></pre>

            <p class="fragment">But in fact, <code>const</code> only prevents the variable from being <em>re-assigned</em></p>
          </section>

          <section>
            <h4>The case for immutability</h4>

            <ul>
              <li class="fragment">Mutating an object is a <em>side effect</em></li>
              <li class="fragment">Mutable objects are <em>hard to follow/read</em></li>
              <li class="fragment">Mutable objects are <em>hard to predict</em></li>
              <li class="fragment">Mutable objects often are the source of hard-to-find <em>bugs</em></li>
              <li class="fragment">Mutable objects are <em>hard to debug</em></li>
            </ul>

            <p class="fragment">So, if immutability is not enforced natively by the language, how do we achieve it?</p>
          </section>

          <section>
            <h3>Immutability as a choice</h3>
            <h4>Plain Objects</h4>

            <pre><code class="javascript" data-trim>
              // Very bad
              const logIn = user => {
                user.loggedIn = true;

                return user;
              };

              const loggedUser = logIn(anonymousUser);

              console.log(loggedUser.loggedIn); // true
              console.log(anonymousUser.loggedIn); // true
            </code></pre>
          </section>

          <section>
            <h3>Immutability as a choice</h3>
            <h4>Plain Objects</h4>

            <pre><code class="javascript" data-trim>
              // Good
              const logIn = user => {
                const userCopy = Object.assign({}, user);

                userCopy.loggedIn = true;

                return userCopy;
              };

              const loggedUser = logIn(anonymousUser);

              console.log(loggedUser.loggedIn); // true
              console.log(anonymousUser.loggedIn); // false
            </code></pre>

            <p class="fragment">Pattern: copy objects and <em>mutate the copy</em></p>
          </section>

          <section>
            <h3>Immutability as a choice</h3>
            <h4>Arrays</h4>

            <pre><code class="javascript" data-trim>
              // Very bad
              const addTask = (taskList, task) => {
                taskList.push(add);

                return taskList;
              };

              const newTaskList = addTask(taskList, task);

              console.log(newTaskList.length); // 10
              console.log(taskList.length); // 10
            </code></pre>
          </section>

          <section>
            <h3>Immutability as a choice</h3>
            <h4>Arrays</h4>

            <pre><code class="javascript" data-trim>
              // Good
              const addTask = (taskList, task) => {
                // or [...taskList, task];
                return taskList.concat(task);
              };

              const newTaskList = addTask(taskList, task);

              console.log(newTaskList.length); // 10
              console.log(taskList.length); // 9
            </code></pre>
            <p class="fragment">Pattern: <em>avoid mutable methods</em> (push, pop, shift, unshift, splice, sort, fill, reverse)</p>
            <p class="fragment">instead <em>use immutable methods</em> (concat, slice, map, filter) or the spread notation</p>
          </section>

          <section>
            <h3>Immutability as a law</h3>
            <p><code>Object.freeze</code> <em>freezes</em> an object, preventing it from being mutated (works w/ arrays as well)</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const user = Object.freeze({ name: 'Elza' });

              user.name = 'Evil'; // throws if in 'strict mode'

              console.log(user.name); // Elza
            </code></pre>

            <p class="fragment">Pattern: combine <code>Object.freeze</code> with other immutable patterns to achieve <em>full immutability</em></p>
          </section>

          <section>
            <p>Note that <code>Object.freeze</code> only freezes objects <em>shallowly</em></p>

            <pre class="fragment"><code class="javascript" data-trim>
              const user = Object.freeze({
                name: {
                  first: 'Elza',
                  last: 'Arendelle'
                }
              });

              user.name.first = 'Evil';

              // { first: 'Evil', last: 'Arendelle' }
              console.log(user.name);
            </code></pre>

            <p class="fragment">So to achieve full immutability all child objects also need to be frozen</p>
          </section>

          <section>
            <p>Note that these patterns are much <em>less performant</em> than it's mutable counterpart</p>
            <p class="fragment">Even more if we're dealing with <em>deep nested objects</em></p>
            <p class="fragment">If you need immutability as well as performance maybe <em>it's time to bring a library in</em></p>
          </section>

          <section>
            <h3>Immutability Libs</h3>
            <ul>
              <li><a href="https://facebook.github.io/immutable-js/">ImmutableJS</a> (by facebook)</li>
              <li><a href="http://swannodette.github.io/mori/">mori</a> (port of ClojureScript data structures)</li>
            </ul>
          </section>

          <section>
            <p>But if performance is still an issue, you should think about replacing parts of your code with mutable patterns</p>
            <p class="fragment">but remember:</p>
            <blockquote class="fragment">
              "Premature optimization is the root of all evil" <br>
              - Donald Knuth
            </blockquote>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li>Managing Function Input</li>
              <li>Function Composition</li>
              <li>Value Immutability</li>
              <li style="color: crimson">Array Operations</li>
              <li>Recursion</li>
              <li>Monads</li>
            </ul>
          </section>

          <section>
            <h3>Array Operations</h3>
            <h4 class="fragment">(or more readable loops)</h4>
          </section>

          <section>
            <h4>Array methods vs Loops</h4>

            <pre><code class="javascript" data-trim data-noescape>
              const activeItems = [];

              for (let i = 0; i < arr.length; i++) {
                if (arr[i].active === true) {
                  activeItems.push(arr[i]);
                }
              }

              // vs

              const activeItems = arr.filter(item => item.active === true);
              <br>
            </code></pre>
          </section>

          <section>
            <h4>Array methods vs Loops</h4>

            <p class="fragment">Array methods are usually better because:</p>
            <ul>
              <li class="fragment">Traversal logic is abstracted</li>
              <li class="fragment">Terser, more readable and <em>declarative code</em></li>
              <li class="fragment"><em>Functions</em> and all it's goodness!</li>
            </ul>

            <p>&nbsp;</p>

            <p class="fragment">Loops are better when:</p>
            <ul>
              <li class="fragment">Performance is needed (still, very questionable)</li>
              <li class="fragment">Need to break out of loop early</li>
            </ul>
          </section>

          <section>
            <h4><code>map()</code></h4>

            <p><code>Array.prototype.map</code> is a <em>HoF</em> that traverses the list applying the provided <em>operator function</em> to each item</p>
            <p class="fragment">and produces a <em>new array</em> with the values returned from each operator call</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const bananas = ['&#x1F34C', '&#x1F34C', '&#x1F34C', '&#x1F34C', '&#x1F34C', '&#x1F34C'];

              const mix = bananas.map((banana, index) => (
                index % 2 === 0 ? '&#x1F34E' : banana
              ));

              console.log(mix); // ['&#x1F34E', '&#x1F34C', '&#x1F34E', '&#x1F34C', '&#x1F34E', '&#x1F34C']
            </code></pre>
          </section>

          <section>
            <h4><code>map()</code></h4>

            <img src="img/array-map.png" alt="An array map representation" style="background: white; width: 500px">
            <p><small>Source: <a href="https://github.com/getify/Functional-Light-JS/blob/master/ch8.md">https://github.com/getify/Functional-Light-JS/blob/master/ch8.md</a></small></p>
          </section>

          <section>
            <h4>A word about the feared <em>Functor</em></h4>

            <p class="fragment">In FP terminology, a Functor is a <em>wrapper object</em> that has a utility method for applying an <em>operator function</em> to it's wrapped value</p>
            <p class="fragment">returning a <em>new Functor</em> wrapping the new value produced by the operator</p>
            <p class="fragment">If the wrapped value is <em>compound</em> the Functor applies the operator to each indidual value instead</p>
            <p class="fragment">All this is just a fancy way of saying that Functor is just an object that has a <em>map</em> method</p>
          </section>

          <section>
            <h4><code>filter()</code></h4>

            <p><code>Array.prototype.filter</code> is a <em>HoF</em> that traverses the list applying the provided <em>predicate function</em> to each item</p>
            <p class="fragment">and produces a <em>new array</em> with the values of which the predicate function returned <em>truthy</em></p>

            <pre class="fragment"><code class="javascript" data-trim>
              const badDiet = ['&#x1F34C', '&#x1F36B', '&#x1F34E', '&#x1F36B', '&#x1F955', '&#x1F36B', '&#x1F349', '&#x1F36B'];

              const goodDiet = badDiet.filter(food => !food.includes('&#x1F36B'));

              console.log(goodDiet); // ['&#x1F34C', '&#x1F34E', '&#x1F955', '&#x1F349']
            </code></pre>
          </section>

          <section>
            <h4><code>filter()</code></h4>

            <img src="img/array-filter.png" alt="An array filter representation" style="background: white; width: 500px">
            <p><small>Source: <a href="https://github.com/getify/Functional-Light-JS/blob/master/ch8.md">https://github.com/getify/Functional-Light-JS/blob/master/ch8.md</a></small></p>
          </section>

          <section>
            <h4><code>reduce()</code></h4>
            <p><code>Array.prototype.reduce</code> is a <em>HoF</em> that traverses the list applying the provided <em>reducer function</em> to the previous returned value and current value</p>
            <p class="fragment">And produces whatever the last reducer call returns</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const people = ['&#x1F469', '&#x1F467', '&#x1F468', '&#x1F466'];

              const family = people.reduce((str, person) => (
                str === '' ? 
                  person :
                  str + '\u200D' + person 
              ), '' /* <- initial value */);

              console.log(family); // '&#x1F469&zwj;&#x1F467&zwj;&#x1F468&zwj;&#x1F466'
            </code></pre>
          </section>

          <section>
            <h4><code>reduce()</code></h4>

            <img src="img/array-reduce.png" alt="An array reduce representation" style="background: white; width: 500px">
            <p><small>Source: <a href="https://github.com/getify/Functional-Light-JS/blob/master/ch8.md">https://github.com/getify/Functional-Light-JS/blob/master/ch8.md</a></small></p>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li>Managing Function Input</li>
              <li>Function Composition</li>
              <li>Value Immutability</li>
              <li>Array Operations</li>
              <li style="color: crimson">Recursion</li>
              <li>Monads</li>
            </ul>
          </section>

          <section>
            <h3>Recursion</h3>
            <h4 class="fragment">(or recursion (or recursion...))</h4>
          </section>

          <section>
            <p>Recursion is when a function <em>calls itself</em> until a <em>base condition</em> is satisfied</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const fib = n => 
                n <= 1 ? 
                  n :
                  fib(n - 2) + fib(n - 1);

              fib(10); // 55
            </code></pre>
          </section>

          <section>
            <h4>Declarative iterations</h4>

            <p>Although it may be <em>less performant</em>, expressing repetition with recursion is usually more readable because of it's <em>declarative</em> nature</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const sum = (...values) => {
                let total = 0;
                for(let i = 0; i < values.length; i++) {
                  total += values[i];
                }
                return total;
              };

              // vs

              const sum = (firstValue, ...otherValues) => 
                otherValues.length === 0 ?
                  firstValue :
                  firstValue + sum(...otherValues);
            </code></pre>
          </section>

          <section>
            <blockquote>
              "Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer. Choose which is more important in your situation!"
              <br>
              - <a href="http://stackoverflow.com/questions/72209/recursion-or-iteration#answer-72694">Leigh Caldwell</a>
            </blockquote>
          </section>

          <section>
            <h4>Divide and Conquer</h4>

            <p>An common strategy to apply when creating a recursive functions is taking the <em>divide and conquer</em> approach:</p>
            <ul>
              <li class="fragment">Treat every list as a <em>pair</em> containing the <em>first value</em> and a list with the <em>rest of the values</em></li>
              <li class="fragment">Define the <em>base condition</em></li>
              <li class="fragment">Define logic around the <em>first value</em></li>
              <li class="fragment">Apply the function itself to the <em>rest of the values</em></li>
            </ul>
          </section>

          <section>
            <h4>Divide and Conquer</h4>

            <p>Iterative:</p>

            <pre><code class="javascript" data-trim>
              const map = (arr, fn) => {
                const newArr = [];

                for (let i = 0; i < arr.length; i++) {
                  newArr.push(fn(arr[i]));
                }

                return newArr;
              };
            </code></pre>

            <div class="fragment">
              <p>Recursive:</p>

              <pre><code class="javascript" data-trim style="max-height: 600px">
                const map = ([firstVal, ...rest], fn) => 
                  firstVal === undefined ? 
                    [] :
                    [fn(firstVal), ...map(rest, fn)];
              </code></pre>
            </div>
          </section>

          <section>
            <h4><code>Stack Overflow</code></h4>

            <p>The function stack is a limited resource</p>
            <p class="fragment">If the base condition of a recursive function is not met until the environment <em>runs out of stack frames</em></p>
            <p class="fragment">The program/application will <em>crash and burn</em></p>

            <pre class="fragment"><code class="javascript" data-trim>
              // If list has something like 200 items or more,
              // Stack Overflow!
              const values = recursiveMap(bigList, item => item.value);
            </code></pre>

            <p class="fragment">Always ensure the base condition will be satisfied before that or refactor the function to use the benefits of <em>tail call optimization</em></p>
          </section>

          <section>
            <h4>Tail call optimization</h4>

            <p>Tail call is when a function call is the <em>very last thing evaluated</em> inside a function</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const foo = () => {
                const value = 'tail call';

                return bar(value); // <- bar is being tail called
              };
            </code></pre>

            <p class="fragment">When this happens the compiler can optimize the runtime by <em>reusing the last stack frame</em></p>
          </section>

          <section>
            <h4>Tail call optimization</h4>

            <p>By refactoring the recursive map utility from:</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const map = ([firstVal, ...rest], fn) => 
                firstVal === undefined ? 
                  [] :
                  [fn(firstVal), ...map(rest, fn)];
            </code></pre>

            <div class="fragment">
              <p>To use <em>TCO:</em></p>

              <pre><code class="javascript" data-trim>
                const map = ([firstVal, ...rest], fn, result = []) => 
                  firstVal === undefined ? 
                    result :
                    map(rest, fn, [...result, fn(firstVal)]);
              </code></pre>
            </div>

            <p class="fragment"><code>map()</code> will now support mapping over lists of any size</p>
          </section>
        </section>

        <section>
          <section>
            <h3>How to FP?</h3>
            <p>Some mandatory topics:</p>
            <ul>
              <li>First Class Functions</li>
              <li>High-Order Functions & Closures</li>
              <li>Function Purity</li>
              <li>Managing Function Input</li>
              <li>Function Composition</li>
              <li>Value Immutability</li>
              <li>Array Operations</li>
              <li>Recursion</li>
              <li style="color: crimson">Monads</li>
            </ul>
          </section>

          <section>
            <h3>Monads</h3>
            <h4 class="fragment">(or the thing that, once understood, you won't be able to explain)</h4>
          </section>

          <section>
            <p>But first, some boring topics that won't be covered:</p>
            <p><small>(but you should at some point)</small></p>

            <ul>
              <li class="fragment">Abstract Algebra</li>
              <li class="fragment">Type Theory</li>
              <li class="fragment">Category Theory</li>
            </ul>

            <p class="fragment">Some people say these fundamental topics are <em>mandatory</em> to start FPing</p>
            <p class="fragment"><em>I disaggree.</em> But when you feel ready to dive into the theory behind FP, it's' recommended you do so</p>
          </section>

          <section>
            <h4>Revisiting Functors</h4>

            <p class="fragment">Meet <em>something</em> and <em>nothing</em>:</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const something = (value) => ({
                map: fn => something(fn(value))
              });

              const nothing = () => ({
                map: nothing
              });
            </code></pre>

            <p class="fragment">
              <small>Note: the names of this Functor implementations <em>vary a lot</em></small>
              <br>
              <small>(Some/None, Just/Nothing, Something/Empty...)</small>
            </p>
            <p class="fragment">
              <small>That happens because Functors, like any other FP <em>type</em>, is like a <em>loose interface</em></small>
              <br>
              <small>Implementations must respect the <em>type laws</em> but their names are not enforced</small>
            </p>
          </section>
          
          <section>
            <h4>Revisiting Functors</h4>

            <p>something is useful</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const getUser = userId => {
                const user = repository.findUserById(userId);

                return user ? something(user) : nothing();
              }
              // now we can write 
              // beautiful, idiomatic, declarative code
              getUser(existingId) // User exists
                .map(attachPermissions(permissions))
                .map(attachOrders(orders))
                .map(showProfile(template));
            </code></pre>
          </section>

          <section>
            <h4>Revisiting Functors</h4>

            <p>nothing is useful</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const getUser = userId => {
                const user = repository.findUserById(userId);

                return user ? something(user) : nothing();
              }
              // now we can write 
              // beautiful, idiomatic, declarative code
              getUser(nonExistantId) // User is not found
                .map(attachPermissions(permissions))
                .map(attachOrders(orders))
                .map(showProfile(profileTemplate));
            </code></pre>

            <p class="fragment">
              It's the same exact code, but nothing happens. Not even an <em>exception</em>!
              <br>
              This allows easier and safer <em>handling of errors</em> without sacrificing readability
            </p>
          </section>

          <section>
            <h4>Revisiting Functors</h4>

            <p>handling branches/errors</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const something = (value) => ({
                map: fn => something(fn(value)),
                orError: nothing
              });

              const nothing = () => ({
                map: nothing,
                orError: something
              });
            </code></pre>
          </section>

          <section>
            <h4>Revisiting Functors</h4>

            <p>handling branches/errors</p>

            <pre class="fragment"><code class="javascript" data-trim style="max-height: 600px">
              const getUser = userId => {
                const user = repository.findUserById(userId);

                return user ? something(user) : nothing();
              }

              // now we can write 
              // beautiful, idiomatic, declarative code
              getUser(nonExistantId) // User is not found
                .map(attachPermissions(permissions))
                .map(attachOrders(orders))
                .map(showProfile(profileTemplate))
                // error branch executed when is nothing
                .orError(new Error('User not found'))
                .map(showError(errorTemplate));
            </code></pre>
          </section>

          <section>
            <h4>Revisiting Functors</h4>

            <p>Containing containers</p>

            <pre class="fragment"><code class="javascript" data-trim style="max-height: 600px">
              const attachPermissions = permissions => user =>
                permissions ?
                  something(user.setPermissions(permissions)) :
                  nothing();

              const attachOrders = orders => user =>
                orders ?
                  something(user.setOrders(orders)) :
                  nothing();

              getUser(userId)
                .map(attachPermissions(permissions))// something(something(user))
                .map(attachOrders(orders))// Error: setOrders is not a function
                .map(showProfile(profileTemplate))
                .orError(new Error('User not found'))
                .map(showError(errorTemplate));
            </code></pre>
          </section>

          <section>
            <h4>Monads to the rescue</h4>

            <p class="fragment">Much like the Functor, the Monad has a utility method for applying an <em>operator function</em> to it's wrapped value</p>
            <p class="fragment">but unlike the Functors <em><code>map()</code></em> utility, it does <em>not</em> return a new Monad.</p>
            <p class="fragment">This utility function has many names: <code>bind()</code>, <code>chain()</code> and <em><code>flatMap()</code></em></p>
          </section>

          <section>
            <h4>Monads to the rescue</h4>

            <p>Unboxing a box</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const something = (value) => ({
                map: fn => something(fn(value)),
                flatMap: fn => fn(value),
                orError: nothing
              });

              const nothing = () => ({
                map: nothing,
                flatMap: nothing,
                orError: something
              });
            </code></pre>
          </section>

          <section>
            <h4>Monads to the rescue</h4>

            <p>Unboxing a box</p>

            <pre class="fragment"><code class="javascript" data-trim style="max-height: 600px">
              const attachPermissions = permissions => user =>
                permissions ?
                  something(user.setPermissions(permissions)) :
                  nothing();

              const attachOrders = orders => user =>
                orders ?
                  something(user.setOrders(orders)) :
                  nothing();

              getUser(userId)
                .flatMap(attachPermissions(permissions)) // something(user)
                .flatMap(attachOrders(orders)) // // something(user)
                .map(showProfile(profileTemplate))
                .orError(new Error('User not found'))
                .map(showError(errorTemplate));
            </code></pre>
          </section>

          <section>
            <h4>You are using monads already</h4>

            <p class="fragment">Let's create a <em>fictional</em> monad that wraps a <em>future value</em></p>

            <pre class="fragment"><code class="javascript" data-trim>
              const future = futureValue => ({
                map: fn => future(fn(futureValue)),
                flatMap: fn => fn(futureValue)
              });
            </code></pre>

            <div class="fragment">
              <p>That can be used like this:</p>

              <pre><code class="javascript" data-trim>
                future(asyncGetUser(userId))
                  .flatMap(asyncAttatchPermissions(userId))
                  .flatMap(asyncAttatchOrders(userId))
                  .map(showProfile(profileTemplate));
              </code></pre>
            </div>
          </section>

          <section>
            <h4>You are using monads already</h4>

            <p>But <em><code>map()</code></em> and <em><code>flatMap()</code></em> are not very meaningful when dealing with future values</p>

            <p class="fragment">What if we <em>merged and renamed</em> them?</p>

            <pre class="fragment"><code class="javascript" data-trim>
              const future = futureValue => ({
                then: fn => typeof futureValue.then === 'function' ?
                  futureValue.then(fn) :
                  future(fn(futureValue))
              });
            </code></pre>

            <div class="fragment">
              <p>Now it reads a lot better:</p>

              <pre><code class="javascript" data-trim>
                future(asyncGetUser(userId))
                  .then(asyncAttatchPermissions(userId))
                  .then(asyncAttatchOrders(userId))
                  .then(showProfile(profileTemplate));
              </code></pre>
            </div>
          </section>

           <section>
            <h4>You are using monads already</h4>

            <p>Feeling a dj vu?</p>

            <pre class="fragment"><code class="javascript" data-trim>
              Promise.resolve(asyncGetUser(userId))
                .then(asyncAttatchPermissions(userId))
                .then(asyncAttatchOrders(userId))
                .then(showProfile(profileTemplate));
            </code></pre>

            <p class="fragment">Yes! Promise is a Monad!</p>
          </section>

          <section>
            <h4>Feel betrayed?</h4>

            <img src="img/betrayed-cat.gif" alt="Gif about a betrayed cat" style="width: 400px">
          </section>
        </section>

        <section>
          <section>
            <h3>Imperative vs Declarative</h3>
            <h4>What this code is doing?</h4>
          </section>

          <section>
            <pre>
              <code class="javascript" data-trim style="max-height: 756px; margin: -40px;">
                const words = [
                    'The', 'quick', 'brown', 'fox,', 'jumps', 'over', 
                    'the', 'lazy', 'dog.', '- It', 'was', 'a', 'german', 
                    'shepherd!'
                ];
                let result = false;

                for (let i = 0; i < words.length; i++) {
                    words[i] = words[i].replace(/[ -_:;.,!\?]/g, '');
                    
                    if (words[i].length >= 3 && words[i].length <= 6) {
                        words[i] = words[i].toUpperCase()
                          .split('').reverse().join('');

                        if (words[i] === 'GOD') {
                            result = true;
                            break;
                        }
                    }
                }

                if (result) console.log('Found GOD...');

                if (words[0] !== 'The') console.log('...and the devil');
              </code>
            </pre>
          </section>

          <section>
            <h4>And this one?</h4>
          </section>
          
          <section>
            <pre><code class="javascript" data-trim style="max-height: 756px; margin: -20px;">
              const words = [
                  'The', 'quick', 'brown', 'fox,', 'jumps', 'over', 
                  'the', 'lazy', 'dog.', '- It', 'was', 'a', 'german', 
                  'shepherd!'
              ];
              const removeInvalidChars = word => word.replace(/[ -_:;.,!\?]/g, '');
              const enoughChars = word => word.length >= 3;
              const canContainGod = word => word.length >= 3 && word.length <= 6;
              const toUpperCase = word => word.toUpperCase();
              const reverseStr = word => word.split('').reverse().join('');
              const toBibleCode = compose(reverseStr, toUpperCase);
              const isGod = word => word === 'GOD';
              const logIf = (condition, str) = condition && console.log(str);

              const result = words
                  .map(removeInvalidChars)
                  .filter(canContainGod)
                  .map(toBibleCode)
                  .some(isGod);

              logIf(result === true, 'Found GOD...');

              logIf(words[0] !== 'The', '...and the devil');
            </code></pre>
          </section>

          <section>
            <h3>Answer:</h3>
            <h4 class="fragment">(Almost) the same thing</h4>
            <p class="fragment">Challenge: Can you spot a difference between both outputs?</p>
          </section>
        </section>

        <section>
          <h3>Developer Evolution</h3>
          <img src="img/fp-evolution.png" alt="">
        </section>

        <section>
          <h3>What to FP?</h3>
          <img class="fragment" src="img/fp-all-the-things.jpg" alt="FP ALL THE THINGS!!!">
        </section>

        <section>
          <h3>JS FP libs</h3>

          <ul>
            <li><a href="https://github.com/lodash/lodash/wiki/FP-Guide">lodash/fp</a> - Functional utilities on top of lodash</li>
            <li><a href="http://ramdajs.com/">Ramda</a> - Functional utilities</li>
            <li><a href="http://functionaljs.com/">functional.js</a> - Functional utilities</li>
            <li><a href="http://folktalejs.org/">Folktale</a> - Suite of functional libraries</li>
          </ul>
        </section>

        <section>
          <h3>Resources</h3>

          <ul>
            <li><a href="https://github.com/getify/functional-light-js">Functional Light JS (by getify)</a> - Great FP book, greatly inspired this talk</li>
            <li><a href="https://github.com/MostlyAdequate/mostly-adequate-guide">Mostly adequate guide to FP</a> - Awesome FP book, dives into theory more</li>
            <li><a href="https://leanpub.com/javascriptallongesix">JavaScript Allong</a> - A must read for every JS developer</li>
            <li><a href="https://github.com/stoeffel/awesome-fp-js">Awesome FP JS</a> - List of resources about FP in JS</li>
          </ul>
        </section>

        <section>
          <h3>Contacts</h3>

          <ul>
            <li>Linkedin: <a href="https://www.linkedin.com/in/allanbaptista/">/in/allanbaptista</a></li>
            <li>Github: <a href="https://github.com/m4n3z40">m4n3z40</a></li>
            <li>Skype: <a href="skype://abaptista.daitan">abaptista.daitan</a></li>
            <li>E-mail: <a href="maito://abaptista@daitangroup.com">abaptista@daitangroup.com</a></li>
          </ul>
        </section>

        <section>
          <h3>Thanks</h3>
          <p>I'm out</p>
          <img src="img/im-out.gif" alt="I'm out!">
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
